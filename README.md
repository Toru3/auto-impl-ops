semi-automatic implementation proc-macro for binary operations

`#[auto_ops]` make implementation for `T += U`, `T + U`, `T + &U`, `&T + U`, `&T + &U` from implementation for `T += &U`.

supported list (`@` is `+`, `-`, `*`, `/`, or `%`.)
* `T @= &U` => `T @= U`, `T @ U`, `T @ &U`, `&T @ U`, `&T @ &U`
* `&T @ &U` => `T @ U`, `&T @ U`, `T @ &U`, `T @= &U`, `T @= U`
* `T @ &U` => `T @ U`, `&T @ U`, `&T @ &U`, `T @= &U`, `T @= U`

# Example

```rust
use std::ops::*;
# 
# #[derive(Clone, Default)]
# struct A<T>(T);

#[auto_impl_ops::auto_ops]
impl<M> AddAssign<&A<M>> for A<M>
where
    for<'x> &'x M: Add<Output = M>,
{
    fn add_assign(&mut self, other: &Self) {
        self.0 = &self.0 + &other.0;
    }
}
```

Above code is expanded into below code.
For more examples see `examples/a.rs`.

```rust
use std::ops::*;
# 
# #[derive(Clone, Default)]
# struct A<T>(T);

impl<'a, M> AddAssign<&'a A<M>> for A<M>
where
    for<'x> &'x M: Add<Output = M>,
{
    fn add_assign(&mut self, other: &Self) {
        self.0 = &self.0 + &other.0;
    }
}
#[allow(clippy::extra_unused_lifetimes)]
impl<'a, M> AddAssign<A<M>> for A<M>
where
    for<'x> &'x M: Add<Output = M>,
{
    fn add_assign(&mut self, rhs: A<M>) {
        self.add_assign(&rhs);
    }
}
impl<'a, M> Add<&'a A<M>> for &'a A<M>
where
    for<'x> &'x M: Add<Output = M>,
    A<M>: Clone,
{
    type Output = A<M>;
    fn add(self, rhs: &'a A<M>) -> Self::Output {
        let mut out = self.clone();
        out.add_assign(rhs);
        out
    }
}
impl<'a, M> Add<A<M>> for &'a A<M>
where
    for<'x> &'x M: Add<Output = M>,
    A<M>: Clone,
{
    type Output = A<M>;
    fn add(self, rhs: A<M>) -> Self::Output {
        let mut out = self.clone();
        out.add_assign(&rhs);
        out
    }
}
impl<'a, M> Add<&'a A<M>> for A<M>
where
    for<'x> &'x M: Add<Output = M>,
{
    type Output = Self;
    fn add(mut self, rhs: &'a A<M>) -> Self::Output {
        self.add_assign(rhs);
        self
    }
}
#[allow(clippy::extra_unused_lifetimes)]
impl<'a, M> Add<A<M>> for A<M>
where
    for<'x> &'x M: Add<Output = M>,
{
    type Output = Self;
    fn add(mut self, rhs: A<M>) -> Self::Output {
        self.add_assign(&rhs);
        self
    }
}
```

# License
`auto-impl-ops` is AGPL-3.0-or-later.
The code generated by this proc-macro is exception of AGPL.
You can choose its license as you like.
