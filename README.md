semi-automatic implementation proc-macro for binary operations

`#[auto_ops]` make implementation for `T += U`, `T + U`, `T + &U`, `&T + U`, `&T + &U` from implementation for `T += &U`.

supported list (`@` is `+`, `-`, `*`, `/`, `%`, `&`, `|`, `^`, `<<` or `>>`.)
* `T @= &U` => `T @= U`, `&T @ &U`, `&T @ U`, `T @ &U`, `T @ U`
* `T @= U` =>  `T @= &U`, `&T @ &U`, `&T @ U`, `T @ &U`, `T @ U`
* `&T @ &U` => `T @= &U`, `T @= U`, `&T @ U`, `T @ &U`, `T @ U`
* `&T @ U` =>  `T @= &U`, `T @= U`, `&T @ &U`, `T @ &U`, `T @ U`
* `T @ &U` => `T @= &U`, `T @= U`, `&T @ &U`, `&T @ U`, `T @ U`
* `T @ U` =>  `T @= &U`, `T @= U`, `&T @ U`, `T @ &U`, `T @ U`

# Example

```rust
use std::ops::*;
# 
# #[derive(Clone, Default)]
# struct A<T>(T);

#[auto_impl_ops::auto_ops]
impl<M> AddAssign<&A<M>> for A<M>
where
    for<'x> &'x M: Add<Output = M>,
{
    fn add_assign(&mut self, other: &Self) {
        self.0 = &self.0 + &other.0;
    }
}
```

Above code is expanded into below code.
For more examples see `examples/a.rs`.

```rust
use std::ops::*;
# 
# #[derive(Clone, Default)]
# struct A<T>(T);

impl<M> AddAssign<&A<M>> for A<M>
where
    for<'x> &'x M: Add<Output = M>,
{
    fn add_assign(&mut self, other: &Self) {
        self.0 = &self.0 + &other.0;
    }
}
#[allow(clippy::extra_unused_lifetimes)]
impl<M> AddAssign<A<M>> for A<M>
where
    for<'x> &'x M: Add<Output = M>,
{
    fn add_assign(&mut self, rhs: A<M>) {
        let rhs = &rhs;
        self.add_assign(rhs);
    }
}
impl<M> Add<&A<M>> for &A<M>
where
    for<'x> &'x M: Add<Output = M>,
    A<M>: Clone,
{
    type Output = A<M>;
    fn add(self, rhs: &A<M>) -> Self::Output {
        let mut lhs = self.clone();
        lhs.add_assign(rhs);
        lhs
    }
}
impl<M> Add<A<M>> for &A<M>
where
    for<'x> &'x M: Add<Output = M>,
    A<M>: Clone,
{
    type Output = A<M>;
    fn add(self, rhs: A<M>) -> Self::Output {
        let mut lhs = self.clone();
        let rhs = &rhs;
        lhs.add_assign(rhs);
        lhs
    }
}
impl<M> Add<&A<M>> for A<M>
where
    for<'x> &'x M: Add<Output = M>,
{
    type Output = A<M>;
    fn add(self, rhs: &A<M>) -> Self::Output {
        let mut lhs = self;
        lhs.add_assign(rhs);
        lhs
    }
}
#[allow(clippy::extra_unused_lifetimes)]
impl<M> Add<A<M>> for A<M>
where
    for<'x> &'x M: Add<Output = M>,
{
    type Output = A<M>;
    fn add(self, rhs: A<M>) -> Self::Output {
        let mut lhs = self;
        let rhs = &rhs;
        lhs.add_assign(rhs);
        lhs
    }
}
```

# License
`auto-impl-ops` is AGPL-3.0-or-later.
The code generated by this proc-macro is exception of AGPL.
You can choose its license as you like.
